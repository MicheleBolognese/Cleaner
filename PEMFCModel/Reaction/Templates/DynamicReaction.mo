within PEMFCModel.Reaction.Templates;
model DynamicReaction "Base dynamic reaction object, to be used as constraining class"
  
  extends PEMFCModel.Reaction.Templates.BaseReaction(MM = (Zx*Medium.MMX) ./ Ztot);
  
  parameter Real Tscale = 1 "Time factor for quasi-equilibrium reactions" annotation(Dialog(tab="Advanced"));
  parameter Real CF_conversion(min = 0, max = 1) = 1 "Conversion efficiency, <= 1";
  input Real kEq_reac[N, n_reac] = ones(N, n_reac) "Temperature-dependent equilibrium constants";
  parameter Real Zx_nominal = 1e-3 "Nominal value for amount of substance, used for numerical scaling" annotation (Dialog(tab="Advanced"));
  parameter .Modelica.Units.SI.AmountOfSubstance epsZ = 1e-6 "Depletion range" annotation (Dialog(tab="Advanced"));
  
  /* Initialization */   
  parameter .Modelica.Units.SI.AmountOfSubstance Ztot_start = pstart*V/(.Modelica.Constants.R*Tstart) "Guessed start value of total amount of moles" annotation(Dialog(enable = false,group = "Initialization"));
  parameter .Modelica.Units.SI.AmountOfSubstance Zx_start[Medium.nS] = Ztot_start*Medium.massToMoleFractions(Xout_start, MMX) "Guessed start value of amount of moles of each component" annotation(Dialog(enable = false,group = "Initialization"));
  
  .Modelica.Units.SI.AmountOfSubstance Zx[N, Medium.nS](stateSelect = StateSelect.always, each nominal = Zx_nominal, min = zeros(N, Medium.nS), start = fill(Zx_start/N, N)) "Amount of moles of each component in each control volume";
  .Modelica.Units.SI.AmountOfSubstance Ztot[N](each nominal = Zx_nominal, each start = Ztot_start/N) "Total amount of moles in each control volume";
  .Modelica.Units.SI.MolarFlowRate Zx_flow[N, Medium.nS] "Net molar flow rate of each component through each control volume (> 0 if entering the control volume) ";
  Real krate[N, n_reac](each start = 0.01, each fixed = true, stateSelect = StateSelect.prefer) "Dynamic reaction rate for each reaction in each control volume";
 
  .Modelica.Units.SI.MolarFlowRate rZ[N, Medium.nS] "Molar rates of each component generated by reactions in each control volume";
  .Modelica.Units.SI.MassFlowRate dmdt = sum(dmdt_cv) "Time-derivative of total mass";
  .Modelica.Units.SI.MolarInternalEnergy g_formation[N, Medium.nS] "Gibbs energy of formation for each component in each control volume";

protected
 
  Medium.ThermodynamicState state[N] "Thermodynamic state in each control volume";
  Real deplZ[N, Medium.nS] "Protection factor against depleted species";
  Real reactant[n_reac, Medium.nS] "Matrix of reactant exponents";
  .Modelica.Units.SI.MolarFlowRate rate[N, n_reac] "Reaction rate vector";
  .Modelica.Units.SI.MassFlowRate dmdt_cv[N] "Time-derivative of total mass in each control volume";
  
  function printInfo "Prints initialization information"
    
    input Integer nS;
    input Real yout_start[nS];
    input String volName;
    input String substanceNames[nS];
    output Boolean dummy;
    
  protected
    
    String errorMsg;
    
  algorithm
    
      errorMsg := volName + ": Initialization with zero molar composition: yout_start = {";
      for i in 1:nS loop
    
        errorMsg := errorMsg + String(yout_start[i]);
        if (i < Medium.nS) then
    
          errorMsg := errorMsg + ",";
    
        end if;

      end for;
      errorMsg := errorMsg + "} (";
      for i in 1:Medium.nS loop

        errorMsg := errorMsg + substanceNames[i];
        if (i < Medium.nS) then

          errorMsg := errorMsg + ",";

        end if;

      end for;
      errorMsg := errorMsg + ")";
      .Modelica.Utilities.Streams.print(errorMsg);
      dummy := true;

  end printInfo;

equation

  // Set state and calculate Gibbs energy of formation
  for i in 1:N loop

    state[i] = Medium.setState_pTX(p[i], T[i], X_out[i,:]);
    g_formation[i, :] = Medium.specificGibbsFormation(state[i]);

  end for;
  for i in 1:N loop

    for j in 1:n_reac loop

      Tscale*der(krate[i, j]) = (kEq_reac[i, j] - 10^(log10_Q_reac[i, j]))/scale;
      rate[i, j] = ((kEq_reac[i, j] - 10^(log10_Q_reac[i, j]))/scale + krate[i,j])*
      10^(- reactant[j, :]*log10_y_out[i, :]);

    end for;
    rZ[i,:] = CF_conversion*rate[i, :]*S_reac;

  end for;
  for i in 1: Medium.nS loop

    reactant[:, i] = {min(0, S_reac[j, i]) for j in 1:n_reac};

  end for;

  /* Molar balance equations for each component */
  for i in 1:N loop

    der(Zx[i, :]) = Zx_flow[i, :] + rZ[i, :].*deplZ[i, :];
    for j in 1:Medium.nS loop

      deplZ[i, j] = .Modelon.Math.Smoothing.spliceFunction(1, 0, Zx[i, j], epsZ);

    end for;
    dmdt_cv[i] = der(Zx[i,:])*MMX;

  end for;
  for j in 1:N loop

    for i in 1:Medium.nS loop

      log10_y_out[j, i] = .Modelica.Math.log10(max(.Modelica.Constants.eps, y_out[j, i]));
      Zx_flow[j, i] = mX_flow[j, i]/MMX[i];
      y_out[j, i] = Zx[j, i]/Ztot[j];

    end for;
     Ztot[j] = sum(Zx[j, :]);

  end for;

  // Equivalent cp not used in dynamic models
  Cp_reac = zeros(N);

initial equation

  // Reaction invariant
  for i in 1:N loop

    Zx[i,:] = yout_start*(pstart*V/N)/(.Modelica.Constants.R*T[i]);

  end for;
  if min(yout_start) <= 0 then

    printInfo(nS=Medium.nS,yout_start=yout_start,volName=volName,substanceNames=Medium.substanceNames);

  end if;

algorithm

  when (min(deplZ) < 1) then
    
    for i in 1:N loop
    
      for j in 1:Medium.nS loop
    
        if deplZ[i,j] < 1 then
    
          .Modelica.Utilities.Streams.print(volName + ": flow component "+Medium.substanceNames[j]+" depleted in node "+String(i)+" due to reactions at time = " + String(time));
    
        end if;

      end for;

    end for;

  end when;

  annotation (Documentation(info="<html>
<h4>DynamicReaction</h4>
<p> This is a default class for reactions using quasi-equilibrium reaction rate. By default it has zero
size reactions, and should be used as the default reaction object in distributed channels.<br>
This model includes the component balances in moles Zx, while the channel model that holds the
reaction object must have the corresponding energy balance. The molar flow rate from convective
flow, Zx_flow, and reactions, rZ, is available as outputs.<br>
The reaction rates are obtained via a quasi-equilibrium approach, the dynamic reaction behavior
can be tuned via parameters Tscale and scale. They act like integral time and inverse gain (k=1/scale)
in a PI-controller.
</p>
 
<p> The model where the reaction object is used should propagate parameter values for
initialization etc. Besides the necessary inputs as specified in the BaseReaction class, 
the following variables should be provided in inheriting classes:<br>
<ul>
  <li> kEq_reac, the reaction equilibrium, given for example using a function of the channel
    temperature.</li>
  <li> reaction parameters, like S_reac and comp, can be set in the final instance, or can be
    provided in specific classes inheriting from this. See e.g. DynamicWGS.</li>
</ul></p>
</html>", revisions="<html>
Copyright &copy; 2004-2024, MODELON AB <br /> The use of this software component is regulated by the licensing conditions for Modelon Libraries. <br />This copyright notice must, unaltered, accompany all components that are derived from, copied from, <br />or by other means have their origin from any Modelon Library.
</html>"));

end DynamicReaction;
